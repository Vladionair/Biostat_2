gAAAAABik1Y7qn4HNhWDdhCb7Z2XT51Z3WLJq_tKXZNNnIm1Oo2uGDNtW8gRsJ5Rf-9EM87CQcuhDccebN6Muo4RtzroXNA3SYfr4V-CfABFrsaEPoFo3o6op8CPoq3xhCtSwobymteRLxCZgnooRQ5chfi74ULFQWGFFkcc3Ho6L4Ko-k8dx0XtJ5_8YKpKKK9TOFkCXSreBrY5eha91vVprmEJiUXABYxYj6QbOkO5r0sgK2b1h9UuVFnz3GJZBaicPwJYq1plsq2Nr0B8yZfQSwD0FkrzaMJxb0xHKARz5vFQHdI_YlguLkEI0obnVfCUnfjo5aB5fOLZeEbT-VmnQrZjJ2ZQ8F_9BTZU5TjoLdwpVM12eIwye7heaR5dJG_VKUtRnReG8DE9lI9sqbJ_Z87Z8zIZlEn7EU_R4M1LzvTS3BbG0nZw3RfUu9QRcprl1mYbi1WtadrEjmRec-1gzVsWlh-Ck_vmtoS7qjdMojIwF9UX9LqfTrGDaBVKHfCf9l8P5G9y-FuuyG0bQgBwYYb912PgzyeGornV5H0YeiZWCwaj_u9Ua_f7IkI0_OyaTUWR0CcxXzBiFXSAtm-QnnCs0nue8gwskbdk_miuX9szhiQ9_1yPQ_rEIGQIzVsCFCvsfrBDrqYX47evecpN_9jOKnSaBYNbYo_thGnjo3xpXFDESupi0SETb4tzY9v1vYC8XFEDJIxF7UazJn0l2WIWfnS1mQcNDRvW7Faq9tMzriMt5ALBQV_QQwCrXpQwv4brOuwxTrt_wq9480ThCsziZnAH6OwhaUYot9daIhMcXc0qg30yJcPyp-OmW7knA-3Y2UV7crSuZOZfQhZ0XR8KPeluG8ehHS2cC_ckJhlKQ456N8WiGQVCTWIE8wylAGF_ilE9fes7_okJJakmhPD3YgvYglb8CVcmf1-5GlR7mvcuhfuMhgFUyAC-KmsgzeDfgsrJpnCzAj6KiFUn6MVdzKSxtmjj4KVl-U_ihMkXS7huggCUXUAZwIYlQxzDObxR5rQ5uWIah9d_7rOXpUk97u2zGz4A7m99GtYV8jTSrk_qTHjbB-5qiqVRzVBQ5T4ZHp18BEe39jFIFQfg6q1635tCnFhDBQn-ljBounwJAL7Iolh8pp84e9-Wt8p4mqfWWNlN0ljVlmCc0QZcYzWsDLooWJ0oQterbPqudP4tmsDhW7RXCmXFuQn9PTgvhObMVEcQPGZhdDgb_i3xMqMYXrs_ahS2Ej-qkVDlFtRkl3BJuNHxqMopEf1kfwnTF7hv8onEwfbdql3jvILaa8RQV_47ZAJwnwPt2llXcCzlmuq51U3IFJ8FkfBuu42ztRoNPte2LwXZuWMdUoEz6H234auD123YzLD5CJCwS9NfdqFop1jltksJFKT50cjTFtU669oJAiIBgI3RRJHRa605Vx73KPA0kht_lMNXzV4zzwthRgULtS0RSOclWMleC9eNttxOZ9IH-FRY1LGqZ3PBTMPfDtEhI8cH5-7e3s-qw6nFEcTBhXnwiy5ihVX0DMSznmUKx4sG99IN9LPgtSq2J5XCDU8Z4-ABpwcWdc9GzjS1zG1BVJTO--wTJeWCpX5A55oFuBmA2Ks5mIfPbIUBEezk5w6BsriZvagHSF3nnUsd-RcKQRLR4wmddh2_Ik54tqVeiCZL-9EEUiteIYWxX0lkge1wmbUjPcFmYSAfOTz9Pcp7gJTebbFnVy7VmCWvA-XsItvLFomiJNXQn578qLLDh4ADFGa-Rz_1XMHyx9CoSphrJPygrUAz6LO67blBqwsFicSnTHFWXvaSNPzwuFA79HWwT3QvZ9ELm5SqIL4APOp4aDLkxl3RVehxKdYR8TreztEJlMUgBUCYQgJSAEuDTefbpbz07U65olgupuedfhyrFZN0a9xojhvIRIEBVyOeEZIl_IJrwavEApfY5GkFudE3fu_G276Vk2laV55YUWei5zC2t2wXRMuTpw2pXN4yCMtqYeJdwOXQ_weJUUWQkH8G956ZLoU6ya8dCHK6PNI663aLcINKTHaa9E0dkqHY23rtN4TYGGtELicCgYrRDEvwQ-93EMcflxvrgxZBrt6frswJ9jc2h2nzFiF2GDQTTtJBYV_yVxNpL2LZDU2QQ_Dg7HrD6ZP7Q18hX4XQ348bNxXkiGXR26Q6K-lfMhX1sptDH7ZBYuk9d_bRJTSFk1lGeaXcSftdpN-Jaq2m2gwJmjc6dxSOLN8SeylGTMRpVlqnE9B2QRjZreOTucXl4h7_RSXm2be-lZyhjlKjbmeHcCaq323mCbB0FEUoRwULm-8X_QMhDBxQ33roZ4IP5DLX1KcOSXcBzwChv7tcTqxcW-dYT7N3HyOepKc7BT6jThUy6Af-h_xWHZ_PtSQ_HXJhFmMFlee2iF1JIkXFowFCBlzfD2o376EkpoNxnqt8z0EPn_-NfJp5OjGnzxMmRHPJKaN60CMGFk9JPzYqZJ3x_69RZjuZWcnIa1vNKPJc5PwFPZghFZEIvDC3Hag0vzvxW8a9DWhJ5JqG4Rd_J1mRLDgpWp54ysEO8t0v-gfwwXnR5sOk4O5qE8xzbputeM3RAxK6VtAkzDbLTFvHdF9lqmq_ygQ-S3NTqxwqmu1KNhCXhajRZ1Oby3WlcSidV2R-p04PRIyHiPbYSOOhmw3_xoLqOXcpovhCe2tc2h-OHy9qdZfH866wiYC4Hqvl5h3ttVaIEkNvB8dWNkoWdAIA3zhnBBMNtnZXnfEijWvS9-rSwJKZFzbgmLGTZj6vork9K26Dgqjq9PlvrDxZAu96EoT_4nOL-6_uOosd4Bib7SxOuu7QnH3W1r4ofNemUm4HCtR3cUzwlLAxkGJatMDWvvbehxN24tVsgEuFfrmjj1xtzB28o6EOezZ9x7KFbvc9ZfqsCcmHvB1P3fb11vG6rdt3UXZCRmzBz659i9_hQ2M9bJzwrgK0aOwD6-37Qb1SK16tdXIheFDcKhzlU_-FzoVyVDlMa8oKbLsXLxl7EjHysGE7CeiOKTvZ12SzRvsJzBbvC-JosTVE91b1c0lQvErB7o1EDYIsttpezOBv2-Uq7aifaII0Qu7iIgta4LNVED7USGYuWn1XgJWFOcaS_YS0OG_DzDXIhdt0bv84dcAf4Il3SfrNx2EfyQfzWuFguyoBcX1LOpB1EXz--oha-0IjfWqICMu_RZnT-xkmEh4ycv6Csa9BcgP6Vn7WNQNMXVJWvrJlenmqhJPkuh8B-eKrJbw0CGI4jdKWWaSST-aNMkzXX2d5727i_3079pMc9E166R-vN32dYJb6bVxbf0by7GtbIHLL4Omk-zW1ujVYm1Xd-ffIOHC-yahx7-YgHWZRphXDygbpGwC7vl7YB1Q1cU8vF_DcxTtX0KN--2bZ6RoGFyj2jax8I8MIBcr8hFl8wkYYbxgKgACpEw9ysj9yIDuo6yVDexMDadUshwmQSa2BgHuHOILI9ICufM-VZiooVdJUJTTRxXPYtfJZu3YDzrLi3w1OWM8LXOZ3laRrQEPpcx8hhodrkPCRridDUkKTuALn_RaabvFmECdVlFs21oFK38fxDEFaXTksO0r9cCWWdJYpyz82-VbokgebHMNKIEk0ST4-QpHJpc9q7EnijOl5eGZc52EvlYXa--5dHwsIfxChTOB4_-qvioOzvxj0w7elMyx80XcTW3wYtav-nIH6l8wqFo6CDQlzSneAY3W1BAuJdSgIUz1t7jLl1lmixrNEnf1nt3n0NnKC63lopkRqSgsRbTpN3JT7r6hhNJMXN_detlxMqXukfM7Imib0AnDvM1SCRndWzVU7z6FdD0xnJ6uw1tSsyO1XyfemR6BYhRY8FeZOnPAtAw9hFtvKSiuKYRM3uLOzsOfXQqj25XQKV6CXkbGWETZBg1U0l19C0q4Av5lQ_sod0ZDjqyT6tNikL4_TJBCCfgyg70MYrQDXl5PY0oOQ_wOMBPmAPs_7_QzE1-LByQiYtgJSIZvQVApDGhdY8oXAnmMdaz4SfRN68wGcjMxnPnpyFnbHgJAolqDMc5GVl8SKlpwx4SFObsp8OxqrLHWHAUnmlVVbXZGqMNz4vIQ6kKEbfrP1HkngplPzJ_nN5-xy0hcLkLZ3W_pmt6r7RL2UCI34vA_cvIRfX5ewN5rWXPUGkb0ewZ3qvbG9An9zO1TDj7CRrPh-Ckl0dpYV63pUTv9bg_RGBoW_HZEHVgYvajn-enrwm0eLGl2CQuJKCzSsyDn1fO0e5KwecoeTe8bsT3PEzJoSsfXFfjfd1no1QaohFZQKmzyQqor83_KGVESRxWTWurSlNWOENA_YUnOcQFsuiT61nF_E1Vz6Xi2LPuaybPRkvDZc2iTh4lpymjL_VxjiXJ3zDZovcS4VWyCjCwQP5_zGLeaEFKxTt-EfpFJUeILITz4s2tYRQ2qs0XO6uRXHOB1sLmdcg_ArCLDGf4F2kbDQ7hRbKYmzi3QHNufpz3fp_gWGFKeW3j3xTuid1eg_VHkcG1NrVBxOkcxpcTvUwG23XscGsIkdGas59FM0MuzYrMLFEMfGJ0vBBsxFx6eiPmt2LDY_yEQA7IUYw732j84NE705kT57K8AViidnlWCm4qhn-V3YoaCqzQT5N6JBhLWL6FkpyQZwUIu_apo5bcUbiEbIGCkqRwJ5llq7Uw8sxNt2M_tJxHzwbQHRjce4mfAMnABLZpLfWy9OnE_iv7MkxvyTyQQgf553Iu32p3nKpKMHquQfcSLn7844P-ls6-1os0q-ZYMb2dax3QsDBWv-cQqrgD400lRuTsLTInWy518TLgOaTYvJA93A5jhNetYx1NtHok2baSRDrzg-61J2xAJPKiehW8KGSxcOCPcd0ujKwzX5A4YOIPJSjuvRJnywD7Y3SsAMRpXk6cLvqdsWN4wxhzwiSEJzGATq9Ytw-HF6lQYhwfQhIdKpTYPVUbDjhAqxB7XADZmdf83q999Pa7suGGciiI5gndLHJRGggYnfkrunNzRySh3pm2_J1SYoNTNPTmY6TB7BV_JjHGc6AY0dA7XtExyZChhiIt4pot0zI9UK7lMJdQfrfvkkCAdtxhDy5Tn8djfLRejiMd5NOLo47Ybo3my-6S2HpihL8TGjX_3KOWtPLcdDKVfbtvLpTPDHRPMkpG2133IrYiuGwn8iYqO6eukuGnguWAZXvjUMrBFfngGMal8uWKnziKLevQDO8aN__D_ikbwEz0R3C7HefR7zbgtzQz_OCGrKExH9w1vAgJ9YAuPQWcHhTCB2M1axrLuXJY1ZTrFlOvFwBgyGdvZE5cHVfORZxBJzhe327kZg88WAm4xOGspQyfyH-UrY_OJU_goZEmfSjh5WnIJ6YKfVNe8ARR4sd9kMeRdED-fmXJ0XSBFXAar8fuh42_j09HFbveM6RK-e4_zCA_y_xlNgWLLxC0dcPDBVMFREn5PjS1RjIn3R_aBYjbx7dFewpv6_BWxIPv3edtll0qs_VZ1qwsbzX4GT7kv3RrOS31NJS5rOhDAIU84ot8ytvhH5isyyNZnH2VPUcECNIjshhp2LooN8E-68LPmAqxvG2su2B6j3gxJxiQURZbFlKdHwmcDVroo_KjtkUDvtptF_MmrP9ZcuTsvYt6X60VPvVq7JAKguW0n2izFhzTmqGl9ZuZ-Qu3l2cfgNtJCJrgfZPQLnlmSZqxAFuWroaGe6NsDPtkH3AjpGDn_lxTE8i1g-O3ilcu-pkzzuGodVxeAOkvdy2lw8jit40PPzrEd-Ifb2F8xP3xnK1kLh-LVuT-t2pmPciZtwSziA-4gNZ9BauvfPFTfFyMgd-MWOp9Kzr4aXRQ-Upm13YXisF5cDJ9X1f9-RUXoRSZooo4pu_V5dlvu-Sk5zTs0EWmNm4eTw7TtKimy0ssNBxn56rKkh5W84Opb0Yx19hsMSASJ4Dr3ARjHZwYRnohyvnyifBtv4V3K4jANuJ_UL7xoI50YyFVFOO6Upi1xPwvDejc-P-1epMz09NrNGt_hjkTNh60QMz48MQH9O46jiZbLUmlhc_cI8OVpouvBLH5CCdUxhp9BrJxdiFrODrM2fL8jJ9B1UkmzeYiKalPPQqm4oWoGxcBpcwWKmRL85It3YjgbT1KZHdwOudFoaxzjEDytMBciGSnD5U3RTnToJ8eeV5ISBGAlCUYbbGXpIrNVz8juiK_msvgIHV9vGGZKENJ7sPX8fn8B3ztwvyeXG_3lwwIhy0HXwa4WrVx41ME0c6WLLyCPaLdSgJUG6ElBExbz8Fs5liZp2xgdyVyRmWpizCRmsvNxKwY-eK3lkSixehz-ryKt7MRtos_2XwfoYUzZjtKOLAOVGmBXg_ndgMiNWcg3ySGjVw31Ioy53tgY6LsumNUxHCp5YHT4ppqOfWozgsDbTfuLq2Yc49A1k1YxMe_eTbsg2o76ibK6oycZUzGCuHiZb_uAp9fBxByqZ_Go-UI-B9UF7vpqHBJvuu6exMhkgDKHAZihczSTSRHTE7DU25phQGaafrh7h4OymgzLWiNH6hYACyrWv23V8-mxQF4CYQK_GyeD59qEaRiCiyjVmXgVC-KiYHltCbuNfW_s0sp-pvIwmlkzO-Jzo1CHOVH9gDCc3BrZLCqTkgpLnBFaGoI7v_jOl2-eQ_XgJw2UfOS9V3s-d_fi6UBp-H0FMboIkZx-yiBRWd2Ae5TigXBUoSZJbtWeiJ-o6nrwSrLDQUsqLpToNibih4NQdnKR-Fd1hu8JUNZZKiUiY2KOXQsfMJc24RvVeiQwsG3ODIX_g3zBobdLyJZWFKDrOofZ6pz9BF1qFxgjyXEwLHi_6peZ6R9n-i1UwLxdAHOZlkhdg9dD2e_KeL28OENYl_wUUtLPN3czr-nr0dGwEaS28z7SSvdH1anoPQGCAJ-xr98G7BIIlHCEMscwog_vbVcslWLyM-SRlRiwnww8EbcPyuL4Mk6zmFJaPAD9xW43CuarEPa4sPpUU1qxHPu9VLudJC1zS8Jd0HIhBZYfNOOets_8A86XQWqhTxOm81IEk-0MM1NGkwH5eQFskfYlutlUB7DTgF5ZXC-TRQ-5w9Hmkqf3COEYk62YPsaSTT_6dliK5jpfgekJH1Z5_f28tU2cnVvIDJ60r2yjcf4UrsibSmxblKeEplo4W63UCyspuo1yOD4nfHhRxNgoMM20d5c7ZrzK8p7gRe3QKa-rWMIwzFJe9EBrRb6wGpc7ASEKxQhupVwBa-hhSA-xQgPLdZfvTTnoib1fAH_FAexRK1mQrPPxRay4B-ER-muMBwn7yXLtM-YeWKqtsnajH7kakR2Sr0G0BUpGAKx_K1XX3eOh1gtHJdBsYS-HqvpHX9Vb4G6yHstpFNdUDLStD2CNkgEEMpsBsynfyaIeud5VWj8QUgpZtzMVYaCZwWjpV8mvH3WH0TX1rWFqXnN8J0vz_NLNkT0wxlTo5mibI0lyMc8gATkmQ1uAE7Z5_SjSr0_cJDwi54N9_NvmrbJWTKlNLJNpQkOXOJsCtQrFZk0hhbOo-cb8RtcEjn-Zb1OYW6xezzp0sqN4sRQpELgUIxWV4OwXgpvN10xKXXpzhZWOa4rN7NTjrA5bNZTbXPxkQFmZzz-nE6nXGgG5ebe4fi5sd2ZiOZUNaFkdLl4k0cIBo1ilZ0mQrkzf7nUa2KsgFA0bVcJEal8CwNQIGIru6dyXxRzkNYYa2cL1nv6lIGYUXJFwE2SX5S7fp2-zehb1j0sfbHazQkl-RipcT8nZyO5R8ArU5GD87h9u2ibbCg-0y-Wz_m0fRTGEuDtqiQgClWa3Rofc-zLtw39iS80FW0MBVEFAI98QipvRIyG2QR2Kl9ZPXS3uINC30lET_whoANVwyUAdX7GqGw3lDTyfwgaFocTLYIW3T7alIcLpJ0tdIjxkWn7fyJXgDz4FoDw9ZS7F24Cp6X5QCdZd89NMKOMJ2hEvUpXl9a7IS_Rn-gvKGrcOLuHgTlhz6cc2Q8iKYEbDAlVX2p5857tNx9YA5dG9aRPZagTMApJZ-Mz_XyVitscxJjG4-KZde82o0t9r16oOq5R0bWeO8sxVKV4IPOa7HTgMKHXEHGD6D1rl4waXY0Byj1utEZx5T2OrbNpUn24W7Q4S0wyCAmYDHIJLB0CdtYO4wZarxdpTMFVnYVy7T_K1TOM6tSOPis2RN5rypgCuH85KvTYw8bYXtt1cuQ0-A3G25ddaADY1188bV88ui1dI9_qKX03QCCy-6UOikFsMl_RR1ZiAp8I7U0gWNxXDtAJNo8jSaJdctVkQQIT_4rTY9LH3NNf4KJIiqUvORJzrx2xOJG6HjsHEu6u0_ZAn8RHDI4HcQhSMuWxEAFesZ7-gBMw2W3zeXkRbnrKjNVET476OJz7qMBu_Z7oYrXHa-LLxP5FVu60ui-NtDV5Bccq39rkSJFwL1DrhqZ01loQ8uRoRGHd0aLflDjKw1aGEvvZMn9N2cHpCJ9lPwcD93lX7OUUXLhLb0O3mdJKYiMJGTSbeakV6mcyTaq3AHzcuUL-x4Z6lFF_4ISEfHZBC2LZ7Gg_0XCtpTFGpT_BTt0oMHr-LIm4rCHYYom9D0pZHWW6fdrvAMbzp8Pe0YSMzLi0TzxY4U145Wo60y2MMXlmPpq2XrNSeDAqVt8NhdEtIhaAQsuM9Pbdav5XB0XNs5EgOhvLCN2k1kQ7f_w7htXIrEG33l0k6wmIC6bMF3_iCwhF4Joc8tl9dyqgwYYsPrRD99TZEoWsTtE7Jslv-8HsdBuLpWasD10HebgC4IkwoqY5bmEYYqbrHqziizIjIdl0DqPRa6g878a-CbWmjwcEMlX7mQODLjS0vpIh6pXUgaPg0IMEv2myuYMW-l3DrXqhm-Ei8kTAxZrfbfOPuUUal-pwHG8sFogZDvd1g3ZeFEaO7kQ8iFxMQ2DZv_NvI4UcnMflyKyLRdoB5Qb3o0gvFAv2KO4m1GZdq1UIOaUHSMT21qc_dPwISxWtQPKP85wlczVRg_-X0ilVgNccKPpxP8QVYoJ2DTAJADuBUZZ5YWLkemk-pPNtaxLW7CN_XS6NflljfX_H8MzX4xsZp-7KSc_8WVYc-mQLsBiHTMQgxVJMtcloWA1g9dLOQ1Y1WojaHkuy7_ArjLEbMe8emz-OCNcorur2rmiB8Bc4V07OlGJCrp8JIRdfen08E-weWp1zihbNL-dvtwZvduYRnFmF4N46SYcEen8tUabprZRRwZ561WQuSi8nmfk0O8fnOrc1Crz_2ZJreuDWJ3TaeZ30nc6ie4D7WxetBsKp-RjuxB5rj3iwrr6BFLBvjgPpYWlIxYmGtywQcqEo3CfJI9JjXaWxVKb9jsa2pQ4bDkzNC3hcX3LiFVXHJ9qaIkf5S89UCMdT_KULMQ5rzRvk8hLgkY4npzme897QZYNDCbNUXufCshIVHzT2WyHiHzlX4VitzmdHavM6-iBjL_BZVMgMogBJfACsYxXocwARljsLmXPEe0_u0f9yMGNSC_s1QO6renlxdq46yaHVCUSW0RyddpfodAepSCGdPHT0brHSxhoQrhnrvuFrLy2PW1JsN7nCMvkMzrMUad-djdPWLWjdEtDXFY42WvPTwyn2tb6vQkJtz8VVw1yg6C5-k0t0KFs5_wHji435VQyThCgHQ7hFJceApHRq4gjN0xLEWuu8FvPvJYYYoTW8cUqpoFcBo2cHir4bEIKtSYUv-o9tU8InZofctq35iobcp_O97p89Uue7-NJXG_aPdIRLaUCv06FNmjRLDY9d-Ius39Ce5HMOXBqPaxctbrSJ1DyZ-gCjrz35puNokYHl2OcGFdygsgMFZ-u1emHuYoNdLl1-XfL4s_3Y_PnTQh010Nl-HcVAaBT0I062yApNL2ZiInj_8yiDNV9WKXjEELXI_X6huOx6lwN7okk7OKc5AyHxS1UY1UpepfetEIhW6hI-N6t8RcexCaqNShkq79aUWNLNXxg49VC81RR1QZDG_coK3WOeQLZtSvka6BCELei1OCPp7jP58XCzf5ecrTcMqROSEPJsOiNQ4Kpkf1_rF8uXW-GWJWq_3qXRDmvfS3vO8w6unyVEHTZBJt42ZQo4e2s3kNPXNdtl9HcjHFXnNuuzFnm909eKnPKLlu_owAuNuALzuJghdyflIyR9Ez_dNaArxphw6V-0s5dEUnwjqIt-082FnQ1N6a8hDhfD6C43WHyojqPSF99aBb4Psx4qPewltvVJ17MqZk98B-0KTJFtFUxApl0M1cqy1f_6DjdEYvx1XTS40TO6nJUuMYGGTkXRvxIWJtCnSlzyp7aEeEiNpB9UcV8mqL1nCOQsFuMOZlVnu9eAFkK9wgaqqTn5kvzc5kQ6PBFgcGb3N5yyE83E7dwi7ewdhu0TVflc4otvCwVDEsumXso3eIyCDgNCHzA1-lJfCjlhJX691jZ2Xownk9FIEchNNWABy736E8YHXDjovQ6iG8BOThO4wZIl6qtix2Ucgj-s3LhkmjMHWSyOfnoSEp2FgEH4ZTAtz496eGIQVRh8eT4oOoj4xmsZrvHHsMprf8Fh2x9VnZSAaEorKoZ5M_YrW_AB4iiHi57asDmNyn3lFOp5ECuMx42G2WTuNmw9iC8u37JzcCbFE5DwVLNsMuvS4pPfrmrpRpP36yZIxq4b7zGwJnnyAf7hC5QryeH-V8YEJSIglOuuQPBjOaEeIcw5nkd4PJoKomSjN1Eug3uk_eefnkwiu5zv24xq5v-HhEfDA7DdzdVjwtQioUyAZ7e9KDO8YVy2b_shCLgBidudcc1VjZTrW0HnRFxIQnsxjlt3XeZIcte0fLDrXcQH3eZjLj-xNpaUHTWiLWk825P4B4tLxX0ZlaNMdD9t2AZALAn981S2dTg_WXWuqmYVVVH9tAj6fqCHuqoQszvoid5A8LnB2XPmfCW9PqBpTgaqcuAFxbbtQLtn-HZyGuEiaRyAq-CaJfNyXoWmcK72HVvysll6Sf3JJ-Oz0tbZjWjUtMi4ysV4Ukf4Pdcewg8Hnc7A_zOF_7nuuZu9TCkGtv3r47rH3Nnec_aEwftT0uHyzELmOLTbSLXB1D433UywtzQtSOugA4ir_VnmroguHkvSXg6351CqBt-kDbJ9LYF9l1p9LGTfQ1ryZeBl6KGerpnIDBQdLW4WXsIHoUjmMfUaSSMOD42bXXxNt36o35Gv5grhzAMz2lgrW-p2ESJzf7vXr76Um9dqj0-gLo9AWiFMh4iENQ71ZmEjxrTlpJ3h81PqEddr_0zlRigYGa7AicsfwNTTS55r10IiVEVcgN9zUxGQSEqAxtJSQSGEbXYzoYaobhTDIKL_IHmOMTStoglPortSmxLllyt8mV27ye9TbZI93VJcRuBEbCTRuvoSNhh1psRmAShz5_01sSv_K_FlmwJhILu3xL-qVWW99zJHIpA7QgurVoy-4R6YqesVmNrbFWeHdvseI1p5S1utrXVKYrL2laA4h3iZkItENNjHnt4cDfVaA86FURuItS5IBDUHG_LYI6a_RLkmdXudGs69NmdzaTmj55jnS4HG5JOk6LJA77J8Dcgn6adih_xnJHWKG3WmLYeMBE_jYthTqFzvukUAvFyKUvhKWWTszWCs2UYZ3d3Yc6il7H5RbctSoeuDZtwxR1L1gBD7zkXst7X4rwY8iP9bIGT4ivcL6fCcfAR6SfamTcnYr7oCqh_rD7_8yeC0YTQA2LFu76yw6XVjViMLtJLYm_yRjg32S3WnN0z5f1Cmh38V5ufpR0L0hWkYuCoOhskU3RhdUziNQFQanhhS0ccW6a3dpH0VieIcfRnvNJ_S0QtMSXp_T9VIbU6N1MVWjCQTLqmhBueMk2QoIweUg6MxzZgHYOZFeeE_PTaP-g2TrMqL6d0fgldIdXqYqjnl7yt-UAUzNbR1TPgG9GCu8yzuA6yM934jB8B_eI8obpOaXInlTo2-jN5exygDeliFeES17F39mtiQPpIGbCnc8RJTA_VpTybYlFQ2zVh_On5BA5W5aKB_ZCtv8RryjFcJ-zZooGrVruHNX0BkehhuhtZtA4MKOBCUp_aBkVtpXO_cUhexADD6vEtOMnKBAGTlqYz9e-kssrkyJE5Xy1QLrSACxo0GyKU2WJYwRwO7a2g4zMLcmrEkHt40Udov0qealuGNMW68NkI1Hb6wDcR3v6PMFlFBiwpb5T3Q_b20UEptSwj35F7AdSRY5mpnKJ5HgJGc3zBi7-5fwkm5tAv_1dwBUbolUT_5ZujTnFotp8sQL_Iqtqhrw9EC1yUFqtcHw_5hYIZpY9dh6a0GLDjneT7uiZW7M-MCddnRAncm1mRrlKwAjnz32Dz9L3LjnkdOysnV2HmZ5BXIoYboS6Gdga2Hm3rjF8Xs1W0eP01HMaEUhQKdcEa-yXMUoQsa7JqB9M8U1TwH6zZitG43Ra9lGxdirJ2_QNYWIuQPxBlVj6OfpYryDdzscS4knbTAbCKAZ3uHZJPvKPdFmre_29toIKnqw_WfrzasmfY59FbB817j2P9hKEBk3uaqVoy2Fpk_xiXdjG0h9p9K9UDRhejoyog2UevlpvNd8TTnh-GOkO7JVP3G-xeJT1u3FjiYvJ8FhaBo_ADa_zZaiQ06-d2tNjpwz66pOYWL55ZCdzopHRkFU0NEwIbvsFDCia3Vj61kkkvlKRgyqoVyoa2eEd0uXy0j23bTwUwaqUMaYT2saiJiWEcm-uIziozbzJeiHoWLud-rBvyhomDNzzY6JgZZ6gFAvayMbMtrUfxG8SW4wdGzYwcOsFnxTiUBGxFbOLVBWRKSJU0yUvyZRDCJqcG1Erewu8agxaIVWHqfQ8d9_-7-kntI1356XKNmvjULPYwT-YJEBUuSZhSgQHWnQwY9T4B5iHXNDcC5qnTdgmSSXQJQPtLJY2xR_6BKz54yT3K8zYyJWSmZFTCMQhGCdUzy_tQuxIV1mHZC4YPSC8PBJO3Yrlwfn1ALoEPheNBLXhKqzMLxFWPz-btNXEV9CfoJu6mTb8b_HBAeQyGZORYim7FZfqCfyICbuwzwSqU3UxdR065FgFlK3HjO8-4xPqg1VMvkZTFh-dp5xYs_xPF4-oSBeb-y34NFJOlrawgPL2uY7-nbLWON-fnSlCbXsyQFRNNtChtYA5rGX_BLcJhI1Vq-lLiqSrTWiNfFwIV5KXCnoNPC1datJm9V9KgjtY8LfdB8aip8SSZYB90zlm-TnPpBTjXnmF9E7WKbqPUr_QcaYHM2Ob4-ruQFndTRRO9ZCV5NejtfNkTcDCPN2BQDgG5PTro9hOTUl_Y_rSJhdxufRiOzbqvK1DiqvXixFBgkhGIhAKaWW6o6DcUi3tCN9Ha8M3frwxqTz7LCgYgeidz-boTZh18pPaf-HkBdVovKlp-Yt23pw-EiTKGhWmgCA_DcBhZe-ervHhb5eyIdWrX3nnOeXvFNoryXfpJCd75EEOC9tunN9A8RODzUCvBsoaJhKsdclw4D-JI0NasPv5n2kht7yT4oNgQ98dYgc-lUiCznJGv15eitL2ObsGvR1gRN-b-4xMEhcCcqc-TMlmwU8ytZh-lRx8D5NEXjdX6VYQEm-ZPeLR6ruF2rw9HNWXaYET68N_cxugxMCFoN6-U-bQT5m4VegMKIZNMVIpAXolDQEDXqjrNe38H8_uZqva0NrmV7-go6uIJ0Q8UQzrHDjRpTC1xIVkhF48kBed0S1IPHpRWS-s3ir_ErwTb1_ATIzOyM45bq9bt54ZUk-3IFQXtQiTYh-0OOa8MrPHC8_RLHmAAL4DqQS4JfH8DZTAVqr8sDKVuHiT61v98FRCRLmHhisDFXWOGscg_iLQlhsE8Q8iEO4UL1AeWSeSAOL-Pn9AX5nAFJxasd8HsQkMt1t7OfpHguiv_orvKuBSHVgGs6ZFOyBnB74ZxGh3PNmeIvoJbU6uDW0AYbVyHYjl7089YF5rwgK8SisTs-yHJatvBGZid7mweSx7hAT5P7xExLpxpEiyWRGSqUeFUurKAhiJ-VcSs3n9yxjWSDGMBpvjkWqtrYCXS71tluoECkb2eNDZtwMcTiJHCUeutDziccDE16um0lBJML6nhpAvjo_0GcHJRsXsGilmh-uhexHGyxAmE9-jM8JbfjIO7dB4J8gGCbqZdA2Qcj8FHMtAhB6v03uaWglDv7W9InKPklWGewXCoYLHPjUQLRRF0JTZixHamUqo7Yc2HZo1050cGY7J1O4je4iCfyp2lJTGDPQkd0uC5vtyab47j5kS3yRSPiSi4lA0yKEJaq3ulmkGHahz3azzgCQ6tSyzHl-ZZ3Le_OFub54SgJorO0ATO67vf4I_2icCvakEDKHgtRN0v7EDamuoGnqJOQ8VQd4b9EyCS2lnsjLkntEjQ-CdIh87LEHRwKz2o-H7nsG1HI188dJWs4fpWiJ2OfCri14LFOu0ni4WFCVwlJoO6dxuRnM0DBykPnnVoYyF4z34FnjB7FxON2tnqlpQAFSIyoSmF3AYTjQ0TKSS0yRE3AEbUFlxz4N-x6WSKP4a4JU86Z1PBxkeQfiw9vcC4cUNMeUMJaeOpSLcp2KcafqBRrClfDYlSm8pzc-wumcm1aqbXGgDojqek-U0cE_7J9nlz6SlsJgWYqEZOWPWFXdnsDC6J9342ilOGPmoKO1svh1n0tfx2IUPyTTrAdxb3iqOLISHTSAqc17UjTJkzWnd2Mt2pwyVa-jArZbd95OvpDyuvfs-9N4t0lzjnIVABhPiIlBmESCO0qeVZfbQ5gtY1RNWEtOd_FgsCnXjNjWoOuH5ZUN-IzRvdgGjq8kMxi_Fnd50Mg6x2JofAEmS9phTXflwCKRepgI4Xct5389zn4JfIgND9h7eT_fuYwBi8BbZcNBw6TPO6skcLqBNl_ZtMLQJ3LQmoKilP4OqbhwsmtQDFw24tSF3Qr1NSVcNCnfCDwYSW7qtWcayHZTyG8ENcI8y1CvQyfFIRf9p3Sf4wA3K9bx7JTP2rT5DOmis-O-lMeQ2vnm6UEsEw5M8p9Lv0GpAuFdOxI7Uu4GLypX9ZAz3cbMNMua6ls052ppfOTqy9etI7ZayPEsrDvAHmFJLuNQyakfnz5Oss92DeNAJOOFI1JG5lMQ0KO19BcXFXgehEa-hJX60m3Zksn1tfQ8atTLTTqEWLAq3I1fZt2Py8HXPyzQgbk8KH3UBPqAFz8j6QgoY4JDje--zFi5kD2gKg8jfj1fPFus96RYAcSzYcYyXC86QOJqAcAyNSsIem1I9uBrCUhqXbaPorlHkdp7pPcFU4a0ddzjd9-duoYfGCpRSakA4ixi31sqsv1b5P7FBLnhv2r_IcZcbv9IdwLXw7wtKfk32KJKZ-qTBdtEgCeQKgmDETMRq3nF9MREzlvOkXIBAkcn0P4Jd8m72OquiZaH10lRzsNNbH8lgbhcuzy9zBz6Uf8R8qHONqRyRzW-ubF57STeDN-PIlM2oYZWSfNrUUKux9wY-Pgq7c6d8SThSV9TeiCA9KWBmxiV06iv2-j0rM4guPl7xVooCcOm36L0yluR68USfORvJz4OnZppj7UMkS4ySPGYPfMb1QF8rJToAOqYcgF3UZyZ32d4UyoMExb2noT05j5sCIXUi0BEWwSTt4M3aoatNHaIRYKZWgJHHvBnmSNhDj8_hcJv80IqQ4iPQDGRd56xVmu_AKtoq7QXXgyQcTIow1gRWtEdKT25RkdLC0-YkJQi5OFOzVNo31W7Na-2zizbF8JXkIRdrxTBVHkvOOFH9VTu9n4wHuuczLQbN3B3K2Rb5WRcYGjdXCcuAuCWHtli6dE3ddHisAvaNwDVHhwiG6wxpoVeFVzG8DeHCcaonlIpjql_1VvH-Kk2UssrWJkVgXjmXf-JT9_DatpAzrkvlCewugXf9lZVgeo_T2czJiUHVEbvzCs7ETdWuWOyb5H4TvStZQSpT0OoMEoVkU4bX1Qmq0Tl-fpcsrrM8hPLc19g0dRffPi7tyHnlHmmSKY0FV1Urm1dUkWOmMbBpbAFqRLrd_K_KTI8xMz65JGyzXUkeCrHWfZrmNfPhxhYHEwKwJ-EqK5Thhe9OFTrKigdOKpkzIX4EEaCELsD1Z1ojwu7VPak-mvLVNVWPaycVRyqzfRTABG1d6CFgaOZ7x44WxcuQw85SnQ5cqLH_DwRTrJVk63cO6Cej1iABiz_fi7vbgRafUaCRvlxXK-gelpQ_ocwwdMhsGbU-O2E_E7tuW6biWuN-OAngzxaGvL9dCKfBGPkqQQlIymRfcuyWSgeh1YJAlt_8jTBbpRlqytrGPwvCRAY5z9zevbEqIPu5HpPrk9Cvrn0ASugOvTfDxjrG1NEpRTBsDENI5nQSOmGxcYMruObAgLLUPvfPfTYXM-WWBECK6XEM7NM0mKxJJ0BvmmTUrxOiSHyDBAfpxrNzVmMS30Kttvp5aSa3_5tfWV09isiF4I15l134LmmzoIOr1ExXUNwv6Z-xVUiLvEGoAPcwZHEAi_BWB8HKjuDfvL-0uYgPlD-p0RP4DYRSrx-8uUe6C9GCsHa1bKW6fL4IeJHFUDym2v16hajGcHs5wumTZ8H5cADD5hYUPCGezFHZNilqnxobpSj4iQnU60TVhoQDGXHrD6cae1PK1gkWoUSacaK4mGp-hN9VhimvFoBL2kJFTZvcvKNXET4eDnjzaR5aPqq9sdqVnrVUHJRRJx2_gDTrUpf2dhdK4v2cR6bSkasfFKZk5HQX_i_UEolBfa63KQ5yYpPpv677HkdqdJph3Ujo3UswmwoJS-ME3pnaOALBF_PXVdXnRBrgbIuj8VL4FQG4_RapUydgO5Xq7VM_RMIsTPiyYLEqcwqwj4B9jjaLcmwVnE26omW4ay7ytxBVg3-sjBuPRjLiFOKeENlSW2FpVDl3TcoduXaGh95jIoDxpWPS-1qvFYdbTyTimDVoWr4esCp1BqbdiI6PGCX6G0TORdrJvAmD6x1RyWE0B_Ss_i47l1sFhQNK_n98RjHbq5hJhxvAot9XR-0rpgeUrlQyu0EYsIn4kgyuHW7VdwfQEe9pQ3SbTwGnfBfspyZ_qmbT-OjfGkutqr8kD6Ir_WFsMTOOUdlYPuPl7RuFrU4YsP-fOLGfpJUrQc_0Fv_9TBQfow2ZBDHy8SUh-zRyMtM4GhwlfczD4QlG8wq0w9iizXttzfdWLHA3EHHJhdu21pPtQfOZIRMnYOZsV1qH4dhARmgoxOtykdcWTLsPuonLmOKUv4y5a_0KxCa0orj2jlbgmqdp-G37TZcd_3QtPHQ3WT_fG7ta-H3CuRZsZuWZLxW6hFLeZc-CvehIeH4cBVqG_iNh72Ylwck2mmobm5FRmnbwRdh21wxjJx5QgbI3jgzkhgbdEcI-PIrm6DSzyAuzV5wmwnc9wjwOhBGHGK83qAyEsvz8rJjIMX3G1bHJlP8CQlVFVDVGVYnVVZViYwsnFCPAKOSY02_y42MQZ1ngMvguaQiBY57LHyRrQ6V233NxkptYAXnpG4__f7quZq6H2_keHBOr-KdayDBcIIbMI6ORa9l7tSf7k44w56l_mmE9SkB5ac3v4mbYKSZA6vriF2nwJH8zWDFnQf-Z7HGF7K6hutYlnyF3qtwT7KbpAvByNR0icNjfGMDoQ2EbkmmnZoi8jQ-El6OUkl7X4aEhGO1ebv-NrlyMzjpcTgc05LiN15oCLPrFgf8LPyUf6BF8Iu71qJIoPEC9BwzrFPGZr1W8mTsLFVBQOd-HO7PwN1CBhgR92f8qlJM53G3N-5-OQHm1uVY7bE8AQB27rAaW17wjSdrY5qBT8bxKUTdPQkEQPG7JK-VwHWd36P2P1r59lTnH21pRueTQDLmGqPAn6MoldLAl1BpG-fKpGBiuwDXmzzXwU-bz4VBj75SiuwACfj8gx2Cltw9WssegNqkvXRHRWcPMTxR-0hZcNYi6rDCI5q3aBHA0iWVNmLj7lu48NZHPnlK7aL5WfZVbMA70sxjeABbma-XegduxmYSDvQQhMFOlhhYoZ1CjGcShRRO17tkslgGPKx1dxHMw25ZHmeXeOANejmHFblTpxaOptsoixPQlZXSgF6CZFe3X4mxRdFTwIvSPDdEFcaGmz-nU1J81zM5fTlNL2Q1fyE31InqkItbuYBK-Zj62UH1DNFl35YjaxY2e_MC3eYjnjAYj3S8vgAtKyQN5wBT5eKDlpjWuHuefwUJKgoKwZcGnypBewRCxCKG7US02n2D9REvJnA_RFjypmUqpApTwn_Lw7K7UYUIayWu9n8TVGE1rJz5Ol2izFZl8vcF2RP1UYaeuEmXFvgdIFnQqx7nMwbMvj9NwCyS_TZLij8wrwGLfLUNiomOqqIRNro_hluO2Sh1cYM9vrIgC8sPCHhNKBSok9mJ5wLXEMp9BYxJO-0hfmfBjvpbgyOI-wc34IdUcQ_Z0NqFtqCXkLXMWQR9fEv9RXKaFnSUJsurqMXbWPFWVPCmG_nwANXAj7fgwSN2kRWmDvXJu4ZucZhrAVBLOMouAq6pAZ3H2USer9SakBR6gpqb7Z-NsvJ9rWENEkCUxSeXUF0WyAik7_7w2j9V3JsB5ZmOHMpfOswC-W7Qsh6DMuRwLf2UFJhIoJjD4eG8TVkz8UnxI0jpOmIyQjavVNsC0c-21IQN74fRmx42Jn8e5hRt-xVn5B5_BYsdHg5yNF6YN_g7RvNeRBdthjuXPD4DocwODuaSP0oM1lXhiurmcZN0ZdYVi2EA7rtsdYNqID-OEQoZQyKtWsAFLTuosQxSRKB9Y6mZh8Z002XpPRSsjeF89EVnyBF4tFFM-RLst-d8eHLJpMYQ3R__-tQtQN679F32UUyOt4UKMco-jGECJJOaslDhZtNMKCCdJ7J-2xxF9uoJAKXhrL_SL8sK_0043VMA-Zr7jp-xiIIWpbJklyKlLVdwFlraGAQF36tshchkx06H3pZxvRAFIno3eD5w4KEA3r509ZCQ04mCFTXEdkV_LcWErhVhLmR-nliNcfzrknb7niyW7dVYuetlgMQotuxmhWHtkC2E68g7vBZzOVgvAtVAN8qZAmIot9YiecCqp5SP_oHG4ggBTLa4XSKJ4LmK139CB_Fzj9e1-ozuot1uYhvK10etLsOjsL5E8o_EPAg5-kVzip6b7o7fkN2cASN4I3iB0BwUaLYgPV41PSzWkypttscrPJ2m2YoW6wz3bh00j7A3LdT55dGMPwPvMmk2G-xpTUsQt1tM3cDKYMXoPezdPRkbdJiDxRSIBoU6y69DoCdhwHhpW_Tc-Df1zprzd-jeyBbKdfWZAyr1ti8oRPz4R4eotPdBsyW56UqjG1a_uKH3tSkmrE5FSKYUhzKqlmPBsYQKpJJnuYpn75pbgOuqiBfy4ADCBhtZBhFEhT9S4qAiBxe-7m-MB-2F_3byqOzYJvCJJ19Nvb_YuGAkaESyv-Por4un0bSuaJxdb-nNVgBD7mwFpcBPzovyas8Z382A317mKoM7E1ST9Oc07Lv-RbLdoxl-jt-9QsZYZjAeL_q4Khlct__X_aXCu7RFNysW6OmulLyiv9I64xAjsqszcTIbWjyelBELEUD2HGPb7_XFwSsPvYf85Ycc59pP5VFL48Jpd3ZO44O38lrGoeFPQD7txEBMByAoECpcH-53e1AohcQGJZN4L4u9bhc8045ZJ37MFcSaHuHJs6VcdXIJtQp5v8Hb17Vo_0BIno6rZkQ1NwSicp_70_C9YKjc-LbkhkJYxUpd22ef0Pdgdb5I3LpTbrvDaIAYN2UaDNbexM3xaLmPlZMR_SARIjhQuO1oQ5fa60bBf5-LVSy_sF8-pKaXxjS6WqnZZOAAgxGlUo76xycGd7_Ul3ZzNlL4mWdUnRZM31St2FSO3EAG1JGH8hIXBPC8TRZP-9s17-MEjJonL5uzBBttJN3MTPa19gRLDvxMLFDGOrakkbJxIZCMkHjpRQ49ju0co4Ym29F9AFN-JKtl0fbi0oYEV8V_wiP2LitUvIL6ONpu9hsNcAVuzcowdkH78ee9P6_rfLkDxKr1yQeq-03llwsGSLKBjiI3NZTa_r7wzgC5id72JLIuUOrsAjVNML1n2U9I4jS4enLlTTOz9sCl68p0dN80lga9KPfU_p1xoLfiPSXp6M5PFmpHwOVvh-Oq0bS4QQGs8VDHpN71IOJPziHs05D0jjwOCPJBEar8KQ8ChTUVuxPngQV8zH13uazRHZVzcgQAY8wnWe2kbdrV7ZSHBh7nKuSOCLMXDTbM9P71OSMNsAoJjig37MKVnSY0X0VpsDVnJoV6MQ0qM142tfi8d8WEBnirtDj6Hlhidh79HOe4ZCu9aeDpZD9y1cPH4v8s0E3VjPsvW4HOUGh7Z3pym8aAFFV27eVEdhFxRK8H4juZeOvcjV3tdSRCYF9L60KE4Cf6kSJsO8G8g1rQLwW4UjjRVDWbNx7WJgMtLhb7F3_pclFrOcXiL-zj_WJscw7uDWYp0rRLHWDbSHuF8xaojOTEIvgrVVEIfk84aBKn9Jq5P-EGIbwbmKvIexq6eHyGjfWivQziOsY1a9LHiv62ZAkl02WlumUfZTCpLLfDfnOmSqWrlQ-u4uFN9KOyIuD2iOzVlKXiEzIIlfUi680uLUuKqLgzZQD6ep-SGMURvWGdCspDiMibb4DIp9k_nvQO1hacvRUTutxwXa4eYm0yAkAAeQ2ZovFn2mO0JsSz6xJKitzKJd9JRKv7yA6TDC6sGxW60fHJWAUgS2QurJZ-up9iAwdoB7uxc11mf0MwWZaQv_bXl3Kr5wsLYNvIQh8tktEKqdnbZ4etIx2cS5tOOgaioA6D6T2mNsiwqpGTiS-3ety0NUAQQ-4DeXkeBXaZj6_CQGlLmYKmfHmGpHXeGZWY-Lbr_zDgil5nZT83OLXINewU7OjDToSfpLNXB5wW0frZ8L5rvj5IrkSUNSgH1kiPQYgCenKlkLxOxUWqwjuRZZnjw2WCWw9weP5ro7rMWCCs9sTQ8uO_hkw937NQAdff9B1UTxhe2X6vwayh0JDiTM4oJ

# Напишите функцию smart_test, которая получает на вход dataframe с двумя номинативными переменными с произвольным числом градаций. Функция должна проверять гипотезу о независимости этих двух переменных при помощи критерия хи - квадрат или точного критерия Фишера.
# Если хотя бы в одной ячейке таблицы сопряженности двух переменных меньше 5 наблюдений, функция должна рассчитывать точный критерий Фишера и возвращать вектор из одного элемента: получившегося p - уровня значимости.
# Если наблюдений достаточно для расчета хи-квадрат (во всех ячейках больше либо равно 5 наблюдений), тогда функция должна применять критерий хи-квадрат и возвращать вектор из трех элементов: значение хи-квадрат, число степеней свободы,  p-уровня значимости.

smart_test <-  function(x){
  t <- table(x)
  ifelse(any(t < 5),
   return(fisher.test(t)$p.value),
   return(unlist(chisq.test(t)[1:3]))
   )
}

# Функция должна возвращать вектор с ﻿названием переменной (или переменных), в которой был получен минимальный p - уровень значимости при проверке гипотезы о равномерном распределении нуклеотидов при помощи критерия хи - квадрат. 

most_significant <-  function(df){
  res <- sapply(df,  function(x) chisq.test(table(x))$p.value)
  res <- names(res[res == min(res)])
}

# Создайте новую переменную important_cases - фактор с двумя градациями ("No" и "Yes"). Переменная должна принимать значение Yes, если для данного цветка значения хотя бы трех количественных переменных выше среднего. В противном случае переменная important_cases  будет принимать значение No.

iris$important_cases <- factor(ifelse(rowSums(sapply(iris[sapply(iris, is.numeric)], function (x) ifelse(x < mean(x), 0, 1))) < 3, 0, 1), labels = c('No', 'Yes'))

# Переменная  important_cases принимает значение Yes, если для данного наблюдения больше половины количественных переменных имеют значения больше среднего. В противном случае переменная important_cases принимает значение No.
# Переменная  important_cases - фактор с двумя уровнями 0 - "No", 1  - "Yes".  То есть даже если в каком-то из тестов все наблюдения получили значения "No", фактор должен иметь две градации. 

get_important_cases <- function(df){
  df$important_cases <- factor(ifelse(rowSums(sapply(df[sapply(df, is.numeric)], function (x) ifelse(x > mean(x), 1, 0))) > length(df) / 2, '1', '0'), labels = c('No', 'Yes'))
  df
}

# Напишите функцию stat_mode, которая получает на вход вектор из чисел произвольной длины и возвращает числовой вектор с наиболее часто встречаемым значением. Если наиболее часто встречаемых значений несколько, функция должна возвращать несколько значений моды  в виде числового вектора. 

stat_mode <- function(x){
  res <- table(x)
  res <- as.numeric(names(which(res == max(res))))
}

# Давайте поможем ему и напишем функцию max_resid, которая получает на вход dataframe с двумя переменными: типом лекарства и результатом его применения. Drugs - фактор с тремя градациями: drug_1, drug_2, drug_3. Result - фактор с двумя градациями: positive, negative. Функция должна находить ячейку таблицы сопряженности с максимальным  значением стандартизированного остатка и возвращать вектор из двух элементов: название строчки и столбца этой ячейки.

max_resid <- function(data) {
  df <- as.data.frame(chisq.test(table(data))$stdres)
  sapply(subset(df, Freq == max(Freq), 1:2), as.character)
}

# Используя библиотеку ggplot2 и встроенные данные diamonds, постройте график распределения частот переменной color, на котором за цвет заполнения столбиков отвечает переменная cut.

obj <-ggplot(diamonds, aes(color, fill=cut)) + geom_bar(position="dodge")

# Напишите функцию get_coefficients, которая получает на вход dataframe с двумя переменными x ( фактор с произвольным числом градаций) и y ( фактор с двумя градациями ﻿). Функция строит логистическую модель, где y — зависимая переменная, а x — независимая, и возвращает вектор со значением экспоненты коэффициентов модели. 

get_coefficients <- function(df){
  res <- exp(glm(factor(y) ~ factor(x), df, family = binomial)$coefficients)
}

# Функция должна возвращать этот же датафрейм, только с центрированными указанными переменными.

centered <- function(df, vars){
  df[vars] <- sapply(df[vars], function(x) x - mean(x))
  df
}

# Напишите функцию get_features , которая получает на вход набор данных о багаже. Строит логистическую регрессию, где зависимая переменная ﻿ - ﻿являлся ли багаж запрещенным, а предикторы - остальные переменные,﻿ и возвращает вектор с названиями статистически значимых переменных (p < 0.05) (в модели без взаимодействия). Если в данных нет значимых предикторов, функция возвращает строку с сообщением  "Prediction makes no sense".

get_features <- function(df){
  res <- glm(factor(is_prohibited) ~ ., df, family = "binomial")
  res <- rownames(subset(anova(res, test = "Chisq"),`Pr(>Chi)` < 0.05))
  `if`(length(res) != 0, res, "Prediction makes no sense")
}

# Используя первый набор данных, обучите регрессионную модель различать запрещенный и разрешенный багаж.

most_suspicious <- function(df1, df2){
  res <- glm(factor(is_prohibited) ~ ., df1, family = "binomial")                     
  res <- predict(res, newdata = df2, type = "response") 
  res <- which(res == max(res))
  return(df2$passanger[res])                               
}

# Напишите функцию normality_test, которая получает на вход dataframe с произвольным количеством переменных разных типов (количественные, строки, факторы) и проверяет нормальность распределения количественных переменных. Функция должна возвращать вектор значений p-уровней значимости теста shapiro.test для каждой количественной переменной.

normality_test <- function(df){
  res <- apply(df[sapply(df,is.numeric)], 2, function(x) shapiro.test(x)$p.value)
}

# Напишите функцию smart_anova, которая получает на вход dataframe с двумя переменными x и y. Переменная x — это количественная переменная, переменная y - фактор, ﻿разбивает наблюдения на три группы.
# Если распределения во всех группах значимо не отличаются от нормального, а дисперсии в группах гомогенны, функция должна сравнить три группы при помощи дисперсионного анализа и вернуть ﻿именованный вектор со значением p-value, имя элемента — "ANOVA".
# Если хотя ﻿бы в одной группе распределение значимо отличается от нормального или дисперсии негомогенны, функция сравнивает группы при помощи критерия Краскела — Уоллиса и возвращает именованный вектор со значением p-value, имя вектора  — "KW".
# Распределение будем считать значимо отклонившимся от нормального, если в тесте shapiro.test() p < 0.05.
# Дисперсии будем считать не гомогенными, если в тесте bartlett.test() p < 0.05.

smart_anova <- function(df){
  p_sh <- aggregate(x ~ y, df, function(x) shapiro.test(x)$p.value)$x
  p_bt <- bartlett.test(x ~ y, df)$p.value   
  if (all(p_sh >= 0.05 ) & p_bt >= 0.05 ){
    anv <- c(ANOVA = summary(aov(x ~ y, df))[[1]]$'Pr(>F)'[1])
  }
  else {
    kw <- c(KW = kruskal.test(x ~ y, df)$p.value)
  }
}

# Функция должна проверять распределение на нормальность в каждой получившейся группе и возвращать dataframe с результатами применения теста ﻿ shapiro.test ﻿﻿(формат вывода смотри ниже).

normality_by <- function(df){
  (names(df) <- c('p_value', 'y', 'z'))
  res <- aggregate(p_value ~ y + z, df, function(x) shapiro.test(x)$p.value)
}

# При помощи библиотеки ggplot2 визуализируйте распределение переменной Sepal.Length в трех группах в данных Iris.

obj <- ggplot(iris, aes(Sepal.Length, fill = Species)) +
  geom_density(alpha = 0.2)

# Напишите функцию smart_hclust, которая получает на вход dataframe  с произвольным числом количественных переменных и число кластеров, которое необходимо выделить при помощи иерархической кластеризации. Функция должна в исходный набор данных добавлять новую переменную фактор - cluster  -- номер кластера, к которому отнесено каждое из наблюдений.

smart_hclust <- function(df, cluster_number){
  df$cluster <- factor(cutree(hclust(dist(df), method = "complete"), cluster_number))
  df
}

# Напишите функцию get_difference, которая получает на вход два аргумента: test_data — набор данных с произвольным числом количественных переменных. n_cluster — число кластеров, которое нужно выделить в данных при помощи иерархической кластеризации. Функция должна вернуть названия переменных, по которым были обнаружен значимые различия между выделенными кластерами (p < 0.05)﻿. 
# Иными словами, после того, как мы выделили заданное число кластеров, мы добавляем в исходные данные новую группирующую переменную — номер кластера, и сравниваем получившиеся группы между собой по количественным переменным при помощи дисперсионного анализа.

get_difference <- function(df, n_clusters){
    fit <- hclust(dist(df))
    cluster <- factor(cutree(fit, n_clusters))
    is.good <- sapply(df, function(x) anova(aov(x ~ cluster))$P[1] < 0.05)
    names(df)[is.good]
}

# Функция должна выполнять анализ главных компонент и добавлять в исходные данные две новые колонки со значениями первой и второй главной компоненты.

get_pc <- function(df){
  df <- cbind(df, prcomp(df, rank. = 2)$x)
  df
}

# Функция должна рассчитать, какое минимальное число главных компонент объясняет больше 90% изменчивости в исходных данных и добавлять значения этих компонент в исходный dataframe в виде новых переменных.

get_pca2 <- function(df){
  perc <- as.vector(summary(prcomp(df))$importance[3,])
  threshold <- perc[perc = perc < 0.9]
  threshold <- append(threshold, min(perc[-threshold]))
  df <- cbind(df, prcomp(df, rank. = length(threshold))$x)
}

# Функция должна проверять существование строгой мультиколлинеарности, а именно наличие линейной комбинации между предикторами. Функция возвращает имена переменных, между которыми есть линейная зависимость или cобщение "There is no collinearity in the data".

is_multicol <- function(x){
  cr <- cor(x)   
  diag(cr) <- 0 
  res <- rownames(which(abs(cr) == '1', arr.ind=T))
  `if`(length(res) == 0, "There is no collinearity in the data", res)
}

# В данных swiss, используя все переменные, выделите два кластера при помощи иерархической кластеризации и сохраните значение кластеров как фактор в переменную cluster. 

# сначала создайте переменную cluster в данных swiss
smart_hclust <- function(df, cluster_number){
  df$cluster <- factor(cutree(hclust(dist(df), method = "complete"), cluster_number))
  df
}

swiss <- smart_hclust(swiss, 2)
# дополните код, чтобы получить график
library(ggplot2)

my_plot <- ggplot(swiss, aes(Education, Catholic, col = cluster)) +
  geom_point() +
  geom_smooth() 
